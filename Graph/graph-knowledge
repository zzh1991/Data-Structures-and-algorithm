图的表示：
1. 邻接矩阵，太耗空间O(V*2)
2. 邻接表：表示图的标准方法；一般使用ArrayList实现，基本是两个表连接起来，O(|E|+|V|)

拓扑排序是对有向无圈图的顶点的一种排序，拓扑排序不必恃唯一的
拓扑排序利用顶点的入度进行排序，找到入度为0的顶点，将其相连的顶点入度减1，继续同样的判断
有DFS和BFS两种实现方式，一般使用BFS实现，利用队列的入队和出对操作

图的入度计算可以通过HashMap来进行映射，或将入队作为图节点的一个成员变量

单源最短路径问题：
1. 无权最短路径：使用队列，先初始化将源入队，然后出对，查看邻接表中的节点，（距离无穷）更新距离和path，然后再将其入队
2. 有权最短路径（Dijkstra算法）：先初始化距离、标记等信息，寻找最小距离的节点，标记访问过，再对其邻接表中的节点（没有标记过的），
更新距离和path信息
可以使用优先队列，即二叉堆的Dijkstra算法，用来寻找最小距离的节点
递归程序显示实际最短路径
3. 具有负边值得图：同1算法，只不过当更新信息的节点不在队列时，需重新入队
所有点对最短路径：对于稀疏图，调用|V|次Dijkstra算法
对于稠密图，采用Floyd算法，可以解决存在一些负值边但没有负值圈的图
三层for循环，最外层是中间节点的遍历

最小生成树
在无向图中找出一颗最小生成树，此树并不是唯一的
Prim算法基本上和求最短路径的Dijkstra算法相同，唯一的区别在于：距离的更新法则不同，只需满足distance = min(weight, distance)

Prim算法和Kruskal算法都可以处理带有负边权的图
求解最大生成树：对所有的边都取反，最后对总距离取反恢复；或者距离更新法则变为：distance = max(weight, distance)；

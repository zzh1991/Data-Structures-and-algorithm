# 树

## 树的遍历

### 递归

* 自顶向下递归遍历
* 自底向上分治

### 迭代（栈实现）

> 递归 -> 非递归，需要用到栈，类似函数调用栈

* 先序遍历：先根，然后右节点，最后左节点
* 中序遍历：一直往左节点走，然后子根节点，最后右节点
* 后序遍历：判断是否有子节点，或者是子根节点已经访问过了，即弹出当前值，并记录（这个）上一个访问节点，不然加入右节点、左节点；或者将先序遍历（根左右）反转
* 层序遍历：队列实现，一层一层遍历；注意需保存每一层的节点个数用于遍历

## 伸展树

* 伸展树（splay tree）的基本思想是：当一个节点被访问时，它就要经过一系列AVL树的旋转被推到根上
* 展开操作不仅将访问的节点移动到根处，而且还把访问路径上的大部分节点的深度大致减少一半（某些浅的节点最多向下推后两层）
* 删除操作：将节点推到根处，删除该节点，得到两颗子树，需左子树中的最大值的节点作为新的根

## B 树

* 原则上B树保证只有少数的磁盘访问。（M叉查找树）
* 有以下特点：1）M-1个关键字；2）根的儿子树在2-M之间；3）非树叶节点儿子数至少半满；4）树叶节点数据项也要达到半满（L）
* 插入操作：1）分裂节点；2）分裂父节点
* 删除操作：领养过程

## 红黑树

红黑树是具有着色性质的二叉查找树：

1. 根是黑色的
2. 如果一个节点是红色的，那么它的子节点必须是黑色的
3. 从一个节点到一个null引用的每条路径必须包含相同的黑色节点

* 基本操作是：1）颜色的改变；2）树的旋转
* 红黑树的优点是执行插入所需要的开销相对较小，实践中发生的旋转相对较少
* 一次双旋转实际上是两个单旋转
* 当遇到带有两个红色儿子的节点，以及插入一片树叶时，需要调用一次树的自调整程序

## huffman 树

* 哈夫曼编码用于文件压缩
* 只有树叶上有数据，0表示左分支，1表示右分支，这种数据结构叫**trie**树

哈夫曼算法：

1. 字符节点组成一颗森林，节点的权值为字符出现的频数
2. 将节点放入优先队列中，依照频数从小到大
3. 取出两个最小频数的节点合并，将频数和赋予新的根节点，并放入优先队列中，重复进行字符个数-1次
4. 从优先队列中取出根节点，此为最优树的根

哈夫曼编解码：

* 编码：从树叶开始往根上爬，直达父亲节点为null；是父亲左儿子为0，右儿子为1
* 解码：从树根开始往树叶溜，直到节点为树叶节点；编码为0向左走，1向右走
